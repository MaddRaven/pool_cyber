#!/usr/bin/env python3

import argparse, re, time, math, hmac, binascii, base64
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.backends import default_backend
from hashlib import sha1


KEY_FILE = "ft_otp.key"
SALT = b"We Are All Mad Here !"
ITERATIONS = 100000
ENCRYPTION_KEY_LENGTH = 32
OTP_DIGITS = 6


def encrypt_key(key):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=ENCRYPTION_KEY_LENGTH,
        salt=SALT,
        iterations=ITERATIONS,
        backend=default_backend()
    )
    key = key.encode('utf-8')
    encrypted_key = kdf.derive(key)
    return encrypted_key


def decrypt_key(encrypted_key):
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=ENCRYPTION_KEY_LENGTH,
        salt=SALT,
        iterations=ITERATIONS,
        backend=default_backend()
    )
    encrypted_key_bytes = encrypted_key.encode('utf-8') if isinstance(encrypted_key, str) else encrypted_key
    derived_key = kdf.derive(encrypted_key_bytes)
    derived_key_hex = derived_key.hex()
    return derived_key_hex


def check_hexa(content):
    pattern = r'^\A(?:[0-9A-Fa-f]{2}\s?)+\Z'
    match = re.match(pattern, content)
    key_len = len(content)

    if match and key_len == 64:
        return True
    else:
        print("Error: Key must be 64 hexadecimal characters")
        return False


def parse_file(file):
    try:
        with open(file, 'r') as f:
            content = f.read().strip()
            if check_hexa(content) is True:
                return encrypt_key(content)
            else:
                return None
    except FileNotFoundError:
        print(f"File {file} can't be opened")


def OTP_generator(file):
    try:
        with open(file, 'rb') as f:
            content = f.read()
            currentTime = math.floor(time.time() / 30)

            decrypted_key_bytes = binascii.unhexlify(decrypt_key(content))
            if not isinstance(decrypted_key_bytes, bytes):
                raise ValueError("Decrypted key bytes must be a bytes-like object")

            currentTimeBytes = str(currentTime).encode()

            hashed = hmac.new(decrypted_key_bytes, currentTimeBytes, sha1)
            hashed_hex = base64.b64encode(hashed.digest()).hex()
            print(hashed_hex)
            print(len(hashed_hex))

            otp = int(hashed_hex, 16) % (pow(10, 6))
            print(otp)
    except FileNotFoundError:
        print(f"File {file} can't be opened")


def parse_arguments():
    parser = argparse.ArgumentParser("OTP Algorithm")
    parser.add_argument('-g', '--get_key', action="store_true", help="Get an hexadecimal key")
    parser.add_argument('-k', '--key_use', action="store_true", help="Create a password with the key")
    parser.add_argument('file', help="key file")
    return parser.parse_args()


def main():
    args = parse_arguments()

    if not args.file:
        print("Usage: ./ft_otp [OPTION] [FILE]")
    elif args.get_key is not True and args.key_use is not True:
        print("Usage: ./ft_otp [OPTION] [FILE]")
    else:
        if args.get_key is True:
            encrypt_key = parse_file(args.file)

            if encrypt_key is not None:
                with open(KEY_FILE, 'wb') as file:
                    file.write(encrypt_key)
                    print("Key was successfully saved in ft_otp.key")

                if args.key_use is True:
                    OTP_generator(KEY_FILE)

        elif args.key_use is True:
            OTP_generator(args.file)


if __name__ == "__main__":
    main()