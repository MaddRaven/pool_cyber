#!/usr/bin/python3

import argparse, requests, re, os, sys, difflib, time
from urllib.parse import urljoin
from bs4 import BeautifulSoup
import importlib.util


def get_form(form):
    details = {
        "action": form.attrs.get("action", "").lower(),
        "method": form.attrs.get("method", "get").lower()
    }
    inputs = [
        {"type": input_tag.attrs.get("type", "text"), 
         "name": input_tag.attrs.get("name"),
         "value": input_tag.attrs.get("value", "")}
        for input_tag in form.find_all("input")
    ]
    details["inputs"] = inputs
    
    return details


def analyze_headers(headers):
    if 'X-Powered-By' in headers and ('PHP' in headers['X-Powered-By'] or 'Apache' in headers['X-Powered-By']):
        return 'MySQL/MariaDB (suggested by PHP/Apache)'
    elif 'Server' in headers and 'Oracle' in headers['Server']:
        return 'Oracle Database'
    elif 'Server' in headers and 'PostgreSQL' in headers['Server']:
        return 'PostgreSQL'
    elif 'SQLite' in headers.get('Server', ''):
        return 'SQLite'
    return None


def analyze_content(parse):
    keywords = {
        'mysql': ['mysql', 'mysqli'],
        'oracle': ['oracledb', 'oracle', 'sqlplus'],
        'sqlite': ['sqlite', 'sqllite'],
        'postgresql': ['postgres', 'postgresql'],
        'mariadb': ['mariadb']
    }
    
    for db_type, db_keywords in keywords.items():
        for keyword in db_keywords:
            if keyword.lower() in str(parse).lower():
                return f'{db_type} (detected in content)'
    
    return None


def detect_database(url, type):
    payloads = ["'", "\"", "`", "\\", "/*'*/", ")'"]
    try:
        s = requests.Session()
        parse = BeautifulSoup(s.get(url).content, "html.parser")
        forms = parse.find_all("form")
        for form in forms:
            details = get_form(form)
            for payload in payloads:
                target_url = urljoin(url, details["action"])
                data = {}
                for input_tag in details["inputs"]:
                    if input_tag["type"] == "text" or input_tag["type"] == "search":
                        data[input_tag["name"]] = payload
                    else:
                        data[input_tag["name"]] = "test"
                if type == "POST":
                    response = requests.post(target_url, data=data)
                else:
                    response =  requests.get(target_url, params=data)

                db_type = analyze_content(response.text)
                if db_type:
                    print(f"Detected database type: {db_type}")
                    return db_type

                db_type = analyze_headers(response.headers)
                if db_type:
                    print(f"Detected database type: {db_type}")
                    return db_type
                
        
    except requests.exceptions.RequestException as e:
        print(f"Error during database detection: {e}")
        return None
    return None


def check_risk(response, db, payload):
    keywords = {
        'mysql': ['mysql', 'mysqli'],
        'oracle': ['oracledb', 'oracle', 'sqlplus'],
        'sqlite': ['sqlite', 'sqllite'],
        'postgresql': ['postgres', 'postgresql'],
        'mariadb': ['mariadb']
    }
    errors = {
        "you have an error in your sql syntax;",
        "warning: mysql",
        ": syntax error",
        "unrecognized token"
    }
    if (db):
        filtered_keywords = [keyword for db_keywords in keywords.values() for keyword in db_keywords if keyword.lower().startswith(db.lower())]
    else:
        filtered_keywords = [keyword for db_keywords in keywords.values() for keyword in db_keywords]
    for keyword in filtered_keywords:
        if keyword.lower() in str(response.text).lower():
            print(f"Risk detected: {payload}")
            return
    for error in errors:
        if error.lower() in str(response.text).lower():
            print(f"Risk detected: {payload}")
            return
    print("Safe")
    return None


def test_flaw(url, type, db):
    try:
        s = requests.Session()
        parse = BeautifulSoup(s.get(url).content, "html.parser")
        forms = parse.find_all("form")
        for form in forms:
            details = get_form(form)

            print("===== TEST UNION =====\n")
            path_to_union = os.path.join(os.path.dirname(__file__), 'union.py')
            spec = importlib.util.spec_from_file_location("union", path_to_union)
            union_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(union_module)
            payloads = union_module.unionPayloads
            i = 0
            for payload in payloads:
                i += 1
                print(f"Union test {i}/415: ",  end='')
                target_url = urljoin(url, details["action"])
                data = {}
                for input_tag in details["inputs"]:
                    if input_tag["type"] == "text" or input_tag["type"] == "search":
                        data[input_tag["name"]] = payload
                    else:
                        data[input_tag["name"]] = "test"
                if type == "POST":
                    response = requests.post(target_url, data=data)
                else:
                    response =  requests.get(target_url, params=data)
                check_risk(response, db, payload)

            print("\n===== TEST ERROR =====\n")
            path_to_error = os.path.join(os.path.dirname(__file__), 'error.py')
            spec = importlib.util.spec_from_file_location("error", path_to_error)
            error_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(error_module)
            payloads = error_module.errorPayloads
            i = 0
            for payload in payloads:
                if type == "POST":
                    response = s.post(url, data=payload)
                else:
                    response = s.get(url, params=payload)
                i += 1
                print(f"Error test {i}/154: ",  end='')
                check_risk(response, db, payload)

            print("\n===== TEST TIME =====\n")
            path_to_time = os.path.join(os.path.dirname(__file__), 'time.py')
            spec = importlib.util.spec_from_file_location("time", path_to_time)
            time_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(time_module)
            payloads = time_module.timePayloads
            i = 0
            for payload in payloads:
                if type == "POST":
                    response = s.post(url, data=payload)
                else:
                    response = s.get(url, params=payload)
                i += 1
                print(f"Time test {i}/92: ",  end='')
                check_risk(response, db, payload)

            print("\n===== BOOL TIME =====\n")
            path_to_bool = os.path.join(os.path.dirname(__file__), 'bool.py')
            spec = importlib.util.spec_from_file_location("bool", path_to_bool)
            bool_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(bool_module)
            payloads = bool_module.boolPayloads
            i = 0
            for payload in payloads:
                if type == "POST":
                    response = s.post(url, data=payload)
                else:
                    response = s.get(url, params=payload)
                i += 1
                print(f"Bool test {i}/77: ",  end='')
                check_risk(response, db, payload)
                
    except requests.exceptions.RequestException as e:
        print(f"Error during vulnerability detection: {e}")


def vaccine(url, type):
    db_engine = detect_database(url, type)
    if not db_engine:
        print("Database not found")
    db = db_engine.split()[0] if db_engine else ""
    
    try:
        test_flaw(url, type, db)
    except requests.exceptions.RequestException as e:
        print(f"Error during vulnerability detection: {e}")


def vaccine(url, type):
    db_engine = detect_database(url, type)
    if not db_engine:
        print("Database not found")
    db = db_engine.split()[0] if db_engine else ""
    
    try:
        test_flaw(url, type, db)

    except Exception as e:
        print(f"Error: {str(e)}")


def validate_args(args):
    if not args.url.startswith(('https://', 'http://')):
        args.url = 'http://' + args.url
    args.X = args.X.upper()
    if args.X != 'POST' and args.X != 'GET':
        print(f"Request type {args.X} not supported")
        sys.exit(1)


def store_results(results, filename):
    with open(filename, 'wb') as file:
        for result in results:
            file.write(result + "\n")
        print(f"Reults writes in {filename}")


def parse_arguments():
    parser = argparse.ArgumentParser("Vaccine programme for testing SQL security")
    parser.add_argument('-o', type=str, default='archive.txt', help="Archive file")
    parser.add_argument('-X', type=str, default='GET', help="Type of request")
    parser.add_argument('url', help="url targeted")
    return parser.parse_args()


def main():
    global url
    args = parse_arguments()
    validate_args(args)
    url = args.url
    vaccine(url, args.X)


if __name__ == "__main__":
    main()

    